# -*- coding: utf-8 -*-
"""Erosion & Dilation .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mAJvMmUD2VCrMbT_tgwR_ENr9jxXREw5
"""

import cv2

"""Erosion"""

img=cv2.imread(r"C:/Users/ashut/Desktop/Course Project_1/Devnagri/MyThinLineData/Digit_0D.jpg",0)
# Apply thresholding to convert the image to binary
thresh_value = 128 # Threshold value
max_value = 255 # Maximum value to use with THRESH_BINARY
_, binary_img = cv2.threshold(img, thresh_value, max_value, cv2.THRESH_BINARY)

# Display the binary image
# cv2.imshow('Binary Image', binary_img)
# cv2.waitKey(0)

# # Getting the structuring kernel
# K_r=cv2.getStructuringElement(cv2.MORPH_RECT,(5,5))
# K_e=cv2.getStructuringElement(cv2.MORPH_RECT,(5,5))
# K_c=cv2.getStructuringElement(cv2.MORPH_CROSS,(5,5))

# E_r=cv2.erode(img,K_r)
# E_e=cv2.erode(img,K_e)
# E_c=cv2.erode(img,K_c)

import matplotlib.pyplot as plt
# plt.subplot(221)
# plt.imshow(img)
# plt.title('Image')
# plt.subplot(222)
# plt.imshow(E_r)
# plt.title('Rectangular kernel')
# plt.subplot(223)
# plt.imshow(E_e)
# plt.title('Elliptical kernel')
# plt.subplot(224)
# plt.imshow(E_c)
# plt.title('Circular kernel')

# # Checking if the resultant binary images are different or not
# import numpy as np
# print(np.sum((E_r - E_c)**2))
# print(np.sum((E_c - E_e)**2))
# # non zero values means they are different

"""Dilation"""

# getStructuringElement
D_r=cv2.getStructuringElement(cv2.MORPH_CROSS,(1,1))
# D_e=cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(5,5))
# D_c=cv2.getStructuringElement(cv2.MORPH_CROSS,(5,5))

#Applying morphological operation
d_r=cv2.dilate(binary_img,D_r)
# d_e=cv2.dilate(img,D_e)
# d_c=cv2.dilate(img,D_c)

#Display the binary image
cv2.imshow('Binary Image', d_r)
cv2.waitKey(0)

# plt.subplot(223)
# plt.imshow(d_e)
# plt.title('Elliptical kernel')
# plt.subplot(224)
# plt.imshow(d_c)
# plt.title('Circular kernel')

# # Checking if the resultant binary images are different or not
# import numpy as np
# print(np.sum((d_r - d_c)**2))
# print(np.sum((d_c - d_e)**2))
# # non zero values means they are different

